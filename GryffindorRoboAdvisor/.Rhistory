# ------------------------
# initiate the map built with leaflet
foundmap <- leaflet() %>%
setView(lng = 0, lat = 30, zoom = 2) %>%
addProviderTiles(providers$Stamen.TonerLite,
options = providerTileOptions(noWrap = TRUE))
#---------------------------------
# add multiple the several layers to combine the single polygons
for (reg.N in 1:length(region)) {
reg <- region[reg.N] # gives the region "code"
tmp <- get(paste("files", reg, sep = ".")) #gives the file name
foundmap <- foundmap %>%
addPolygons(data = tmp,
fillColor = colors[reg.N],
color = "#000000",
opacity = 1,
fillOpacity = 0.7,
dashArray = "3",
stroke = TRUE,
weight = 1.5,
smoothFactor = 0.2,
# highlight = highlightOptions(
#         weight = 1,
#         color = "#000000",
#         dashArray = "3",
#         fillOpacity = 0.8,
#         bringToFront = TRUE),
label = paste(groups[reg.N]),
group = paste(groups[reg.N])
)
}
#---------------------------------
# set up layer controls
foundmap <- foundmap %>%
addLayersControl(overlayGroups = groups,
options = layersControlOptions(collapsed = FALSE))
# ------------------------
# integrate the map into shiny
output$mymap <- renderLeaflet({foundmap})
###---###---###---###---###---###---###---###---###---###---###---###---###
##---Portfolioevaluation functions
# Average return - takes one column as an input
averagereturn <- function(backtest){
portfoliologreturns <- data.frame()
for(r in 1:(nrow(backtest) - 1)){
portfoliologreturns[r, 1] <- log(backtest[r + 1, 1]/backtest[r, 1])
}
averagereturn <- mean(portfoliologreturns[, 1]) * 252
return(averagereturn)
}
# Calculate max drawdown - takes one column as an input
maxdrawdown <- function(backtest){
trailingmaxdrawdown = data.frame()
for(r in 1:(nrow(backtest) - 1)){
trailingmaxdrawdown[r, 1] <- min(tail(backtest[, 1], -r)) /
backtest[r, ] - 1
}
maxdrawdown <- min(trailingmaxdrawdown[, 1])
return(maxdrawdown)
}
# Calculate annual standard deviation
yearlystd <- function(backtest){
portfoliologreturns <- data.frame()
for(r in 1:(nrow(backtest) - 1)){
portfoliologreturns[r, 1] <- log(backtest[r + 1, 1] / backtest[r, 1])
}
yearlystd <- sd(portfoliologreturns[, 1]) * sqrt(252)
return(yearlystd)
}
# Calculate sharpe Ratio for maximization
sharpe <- function(expectedreturn, covmatrix, par){
#optim, used, later needs the parameters as vector, but we need it as matrix
#here - therefore we have to change back and forth
par <- as.matrix(par)
par <- rbind(par, 1 - sum(par[, 1]))
#Calculate Portfolio return
pfreturn <- t(expectedreturn) %*% par
#Calculate Portfolio standard deviation
pfvar <- t(par) %*% covmatrix %*% par
#Calculate Sharpe Ratio
sharperatio <- pfreturn / (pfvar ^ 0.5)
return(sharperatio)
}
###---###---###---###---###---###---###---###---###---###---###---###---###
##---Portfolio Creation---###
#test dataframe
# chosendata <- as.data.frame(newData())
# rownames(newData()) <- newData()[, 1]
# chosendata <- chosendata[, -1]
### Sharperatio optimized pure Equity Portfolio
# Takes a dataframe with all indices as input
optimpf <- function(data){
#get past returns
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data) - 1){
returns[r, c] <- (data[r + 1, c] - data[r, c]) / data[r, c]
}
}
#startingweights for optimisation -1 so that weights add up to 1
startingweights <- as.matrix(rep(1/ncol(data),length.out=(ncol(data)-1)))
expectedreturn <- as.matrix(rep(0,length.out=ncol(data)))
#return and covariances as matrixes
returnmatrix <- as.matrix(returns[,])
covmatrix <- cov(returnmatrix)
#expected returns for every stock
for(c in 1:ncol(returns)){
expectedreturn[c,1] <- mean(returns[,c])
}
#Find Optimal portfolioweights given the lower bound of 0 and the shareratio function defined above
optweights <- optim(par = as.vector(startingweights), fn = sharpe,
expectedreturn = expectedreturn, covmatrix = covmatrix ,
control=list(fnscale=-1),lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
optweights <- rbind(optweights, 1-sum(optweights))
#Indexed Portfolio
indexportfolio <- data.frame()
for(c in 1:ncol(data)){
indexportfolio[1,c] <- 100
}
for(c in 1:ncol(data)){
for(r in 1:nrow(returns)){
indexportfolio[r+1,c] <- indexportfolio[r,c]*(1+returns[r,c])
}
}
colnames(indexportfolio) <- NULL
rownames(indexportfolio) <- NULL
#Form Portfolio with the sharperatio optimal weights
portfolio <- data.frame()
for(r in 1:nrow(indexportfolio)){
portfolio[r,1] <- as.numeric(as.matrix(indexportfolio[r,]) %*% optweights)
}
#Returns a Portfolio Indexed to 100
return(portfolio)
}
### Equity + Debt Portfolio
equityanddeptpf <- function(equity, dept, equityaspercent){
bondindex <- data.frame(matrix(NA,ncol = 2,nrow = nrow(equity)))
bondindex[,1] <- dept
bondindex[,2] <- dept
dept <- optimpf(bondindex)
portfolio <- data.frame()
for(r in 1:nrow(equity)){
portfolio[r,1] <- equity[r,1]*equityaspercent + dept[r,1]*(1-equityaspercent)
}
return(portfolio)
}
indexpf <- function(data){
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data)-1){
returns[r,c] <- (data[r+1,c]-data[r,c])/data[r,c]
}
}
indexportfolio <- data.frame()
for(c in 1:ncol(data)){
indexportfolio[1,c] <- 100
}
for(c in 1:ncol(data)){
for(r in 1:nrow(returns)){
indexportfolio[r+1,c] <- indexportfolio[r,c]*(1+returns[r,c])
}
}
return(indexportfolio)
}
###---###---###---###---###---###---###---###---###---###---###---###---###
##---Test Functions for Markdown file---##
nicegraph <- function(x=1000) {
plot(sin(1:x), cos(1:x))
}
piechart <- function(x=c(0.3,0.2,0.1,0.4)) {
pie(x)
}
randperform <- function(x=cumsum(rnorm(1000,1,5))) {
plot(x)
}
testplot <- function(x) {
plot(x)
}
### Risk Parity Portfolio
riskparity <- function(covmatrix, par){
par <- as.matrix(par)
par <- rbind(par, 1-sum(par[,1]))
startingweights <- par
marginalrisk <- covmatrix%*%startingweights
contribution <- as.matrix(as.numeric((startingweights*marginalrisk)))/sqrt(as.numeric((t(startingweights)%*%covmatrix%*%startingweights)))
portfoliorisk <- sqrt(as.numeric((t(startingweights)%*%covmatrix%*%startingweights)))
contributionpercent <- matrix(ncol = 1, nrow = 3)
for(r in 1:nrow(contribution)){
contributionpercent[r,1] <- contribution[r,1]/sum(contribution)
}
if(par[1,1]+par[2,1]>1){
portfoliorisk <- 3
}
portfoliorisk <- abs((contributionpercent[1,1]-contributionpercent[2,1]))+
abs((contributionpercent[1,1]-contributionpercent[3,1]))
return(portfoliorisk)
}
riskparitypf <- function(equity, dept, commodity){
data <- as.matrix(cbind(equity,dept,commodity))
startingweights <- as.matrix(rep(1/ncol(data),length.out=(ncol(data)-1)))
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data)-1){
returns[r,c] <- (data[r+1,c]-data[r,c])/data[r,c]
}
}
returnmatrix <- as.matrix(returns[,])
covmatrix <- cov(returnmatrix)
optweights <- optim(par = as.vector(startingweights), fn = riskparity,
covmatrix = covmatrix,lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
optweights <- rbind(optweights,1-sum(optweights))
portfolio <- data.frame(100)
for(r in 1:nrow(returns)){
portfolio[(1+r),1] <- portfolio[r,1]*(1+(returns[r,1]*optweights[1,1]+
returns[r,2]*optweights[2,1]+
returns[r,3]*optweights[3,1]))
}
return(portfolio)
}
### MinVar Portfolio
minvar <- function(covmatrix,par){
par <- as.matrix(par)
par <- rbind(par, 1-sum(par[,1]))
std <- t(par)%*%covmatrix%*%par
if(par[1,1]+par[2,1]>1){
std <- 3
}
return(std)
}
minvarpf <- function(data){
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data)-1){
returns[r,c] <- (data[r+1,c]-data[r,c])/data[r,c]
}
}
returnmatrix <- as.matrix(returns[,])
covmatrix <- as.matrix(cov(returnmatrix))
startingweights <- as.matrix(rep(1/ncol(data),length.out=(ncol(data)-1)))
optweights <- optim(par = as.vector(startingweights), fn = minvar,
covmatrix = covmatrix,lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
optweights <- rbind(optweights,1-sum(optweights))
portfolio <- data.frame(100)
for(r in 1:nrow(returns)){
portfolio[(1+r),1] <- portfolio[r,1]*(1+(as.matrix(returns[r,])%*%optweights))
}
return(portfolio)
}
##### call the portfolios according to the user's input ###################
########################################################
######### short bond only ###############
output$ourPF <- renderPlot({
if(input$rpref2 == 1 && input$inv_horizon <= 5) {
plot.ts(shortbond)
summary(shortbond)
}
######## long bond only #################
if((input$rpref2 == 2 && input$inv_horizon <= 5) ||
(input$rpref2 == 1 && input$inv_horizon > 5 && input$inv_horizon <= 10)) {
plot.ts(longbond)
summary(longbond)
}
if((input$rpref2 == 3 && input$inv_horizon <= 5) ||
(input$rpref2 == 3 && input$inv_horizon < 5 && input$inv_horizon <= 10) ||
(input$rpref2 == 2 && input$inv_horizon < 5 && input$inv_horizon <= 10)) {
rownames(ovr) <- ovr[,1]
ovr <- ovr[,-1]
flor <- floor(ncol(ovr)/15)
remaining <- ncol(ovr)-15*flor
lastdata <- flor+1
for(n in 1:flor){
data.n  <- ovr[((n-1)*15+1):(n*15)]
assign(as.character(paste("data", as.character(n),sep="")),data.n)
}
data.lastdata <- ovr[(flor*15):ncol(ovr)]
assign(as.character(paste("data", as.character((flor+1)),sep="")),data.lastdata)
finaldata <- data.frame(matrix(nrow = nrow(ovr)))[,-1]
for(n in 1:(flor+1)){
dataopt<- minvarpf(get(paste("data",n,sep="")))
assign(as.character(paste("dataopt", as.character(n),sep="")),dataopt)
finaldata <- cbind(finaldata,dataopt)
}
finalpf <- minvarpf(finaldata)
plot.ts(finalpf)
summary(finalpf)
}
if (input$rpref2 == 1 && input$inv_horizon > 10) {
######################### Equity + longbond viel bond #################
}
if((input$rpref2 == 4 && input$inv_horizon <= 5) ||
(input$rpref2 == 5 && input$inv_horizon <= 5) ||
(input$rpref2 == 4 && input$inv_horizon < 5 && input$inv_horizon <= 10) ||
(input$rpref2 == 5 && input$inv_horizon < 5 && input$inv_horizon <= 10) ||
(input$rpref2 == 3 && input$inv_horizon > 10) ||
(input$rpref2 == 4 && input$inv_horizon > 10)) {
######################### risk parity ##########################
}
if((input$rpref2 == 6 && input$inv_horizon <= 5) ||
(input$rpref2 == 6 && input$inv_horizon < 5 && input$inv_horizon <= 10) ||
(input$rpref2 == 5 && input$inv_horizon > 10)) {
######################### Equity + longbond viel equity ########
}
if ((input$rpref2 == 6 && input$inv_horizon > 10) ||
(input$rpref2 == 7 && input$inv_horizon <= 5) ||
(input$rpref2 == 7 && input$inv_horizon < 5 && input$inv_horizon <= 10) ||
(input$rpref2 == 7 && input$inv_horizon > 10)) {
########################## Pure Equity² #########################
flor <- floor(ncol(newData()) / 15)
remaining <- ncol(newData()) - 15 * flor
lastdata <- flor + 1
for(n in 1:flor){
data.n  <- newData()[((n-1)*15+1):(n*15)]
assign(as.character(paste("data", as.character(n),sep="")),data.n)
}
data.lastdata <- newData()[(flor*15):ncol(newData())]
assign(as.character(paste("data", as.character((flor+1)),sep="")),data.lastdata)
finaldata <- data.frame(matrix(nrow = nrow(newData())))[,-1]
for(n in 1:(flor+1)){
dataopt<- optimpf(get(paste("data",n,sep="")))
assign(as.character(paste("dataopt", as.character(n),sep="")),dataopt)
finaldata <- cbind(finaldata,dataopt)
}
finalpf <- optimpf(finaldata)
}
plot.ts(as.matrix(finalpf))
})
# PDF Download Handler
output$downloadReport <- downloadHandler(
filename = function() {
paste('my-report', sep = '.', switch(
input$format, PDF = 'pdf', HTML = 'html', Word = 'docx'
))
},
content = function(file) {
src <- normalizePath('report.Rmd')
# temporarily switch to the temp dir, in case you do not have write
# permission to the current working directory
owd <- setwd(tempdir())
on.exit(setwd(owd))
file.copy(src, 'report.Rmd', overwrite = TRUE)
library(rmarkdown)
out <- render('report.Rmd', switch(
input$format,
PDF = pdf_document(), HTML = html_document(), Word = word_document()
))
file.rename(out, file)
}
)
###---###---###---###---###---###---###---###---###---###---###---###---###
##---ValueBoxes---##
output$horizonBox <- renderValueBox({
valueBox(
paste0(input$inv_horizon, " years"), "Investment Horizon", icon = icon("hourglass-half"),
color = "blue"
)
})
output$returnBox <- renderValueBox({
valueBox(
paste0(drift[input$rpref] * 100, "%"), "Return", icon = icon("chart-line"),
color = "green"
)
})
output$stdBox <- renderValueBox({
valueBox(
paste0(diffusion[input$rpref] * 100, "%"), "Standard Deviation", icon = icon("square-root-alt"),
color = "red"
)
})
output$avgBox <- renderValueBox({
if (sum(sim$data) == 0) {
valueBox(
paste0(NA, "$"), "Average Value", icon = icon("hand-holding-usd"),
color = "blue"
)
} else {
valueBox(
paste0(round(mean(sim$data)), "$"), "Average Value", icon = icon("hand-holding-usd"),
color = "blue"
)
}
})
output$uplimBox <- renderValueBox({
if (sum(sim$data) == 0) {
valueBox(
paste0(NA, "$"), "90% Limit Profit", icon = icon("greater-than"),
color = "green"
)
} else {
valueBox(
paste0(round(sim$data[order(sim$data)[length(sim$data)*0.9]] - input$initial_wealth), "$"), "90% Limit Profit", icon = icon("greater-than"),
color = "green"
)
}
})
output$lowlimBox <- renderValueBox({
if (sum(sim$data) == 0) {
valueBox(
paste0(NA, "$"), "10% Limit Loss", icon = icon("less-than"),
color = "red"
)
} else {
valueBox(
paste0(round(sim$data[order(sim$data)[length(sim$data)*0.1]] - input$initial_wealth), "$"), "10% Limit Loss", icon = icon("less-than"),
color = "red"
)
}
})
output$horizonBox1 <- renderValueBox({
valueBox(
paste0(input$inv_horizon, " years"), "Investment Horizon", icon = icon("hourglass-half"),
color = "blue"
)
})
output$returnBox1 <- renderValueBox({
valueBox(
paste0(drift[input$rpref2] * 100, "%"), "Return", icon = icon("chart-line"),
color = "green"
)
})
output$stdBox1 <- renderValueBox({
valueBox(
paste0(diffusion[input$rpref2] * 100, "%"), "Standard Deviation", icon = icon("square-root-alt"),
color = "red"
)
})
output$avgBox1 <- renderValueBox({
valueBox(
paste0(round(mean(sim$terminal_wealth)), "$"), "Average Value", icon = icon("hand-holding-usd"),
color = "blue"
)
})
output$uplimBox1 <- renderValueBox({
valueBox(
paste0(round(sim$terminal_wealth[order(sim$terminal_wealth)[draws*0.9]] - input$initial_wealth), "$"), "90% Limit Profit", icon = icon("greater-than"),
color = "green"
)
})
output$lowlimBox1 <- renderValueBox({
valueBox(
paste0(round(sim$terminal_wealth[order(sim$terminal_wealth)[draws*0.1]] - input$initial_wealth), "$"), "10% Limit Loss", icon = icon("less-than"),
color = "red"
)
})
###---###---###---###---###---###---###---###---###---###---###---###---###
##---Switch Buttons---##
# Switch Tabs with action buttons
observeEvent(
input$button1, {
newtab <- switch(input$tabs, "tab1" = "tab2")
updateTabItems(session, "tabs", newtab)
}
)
observeEvent(
input$button2, {
newtab <- switch(input$tabs, "tab2" = "tab1")
updateTabItems(session, "tabs", newtab)
}
)
observeEvent(
input$button3, {
newtab <- switch(input$tabs, "tab2" = "tab3")
updateTabItems(session, "tabs", newtab)
}
)
observeEvent(
input$button4, {
newtab <- switch(input$tabs, "tab3" = "tab2")
updateTabItems(session, "tabs", newtab)
}
)
observeEvent(
input$button5, {
if (is.null(input$mymap_groups)) {
sendSweetAlert(
session = session,
title = "Error Message",
text = "Please select at least one region!",
type = "error"
)
} else {
newtab <- switch(input$tabs, "tab3" = "tab4")
updateTabItems(session, "tabs", newtab)
}
}
)
observeEvent(
input$button6, {
newtab <- switch(input$tabs, "tab4" = "tab3")
updateTabItems(session, "tabs", newtab)
}
)
observeEvent(
input$button7, {
newtab <- switch(input$tabs, "tab4" = "tab5")
updateTabItems(session, "tabs", newtab)
}
)
observeEvent(
input$button8, {
newtab <- switch(input$tabs, "tab5" = "tab4")
updateTabItems(session, "tabs", newtab)
}
)
###---###---###---###---###---###---###---###---###---###---###---###---###
} # end of server
runApp(shinyApp(ui,server),launch.browser = TRUE)
load("C:/Users/Matthias Speicher/Documents/GitHub/Group2_Project/GryffindorRoboAdvisor/.RData")
load("C:/Users/Matthias Speicher/Documents/GitHub/Group2_Project/GryffindorRoboAdvisor/mydf.RData")
View(mydf)
