if (class(result.m) == "numeric") {
invisible(result.m)
} else {
rownames(result.m) <- 1:nrow(result.m)
colnames(result.m) <- c("X", "Y")
invisible(result.m) # return value which can be assigned but don't print
}
}
# Summary function
summary.m <- function(result) {
if (class(result) == "numeric") {
cat("The estimated position is: \nX=", result[1], "\nY=", result[1])
} else {
cat("The estimated positions are: \n")
print(result)
}
}
# Plotting function
plot.m <- function(x = c(-300,300,0), y = c(300,300,-300),result) {
if (class(result) == "numeric") {
plot(x = x, y = y, pch=21, cex = 3, col = "black", bg = c("red", "green", "blue"), panel.first = grid(), asp = 1)
symbols(0,0, circles = 200, add = T, inches = F, bg = "grey")
points(x = result[1], y = result[2], pch = 4, col = "orange", lwd = 2, cex = 2)
} else {
plot(x = x, y = y, pch=21, cex = 3, col = "black", bg = c("red", "green", "blue"), panel.first = grid(), asp = 1)
symbols(0,0, circles = 200, add = T, inches = F, bg = "grey")
points(x = result[,1], y = result[,2], pch = 4, col = "orange", lwd = 2, cex = 2)
}
}
#starting_values <- c(100, 10, 10)
distances <- rbind( c(458.9474, 337.1013, 363.1112),
c(337.0894, 458.9355, 363.0993),
c(442.5835, 442.5835, 283.9493),
c(520.1845, 520.1845, 184.0449),
c(534.1411, 499.0299, 191.3455),
c(499.1322, 534.2434, 191.4479),
c(542.0904, 470.4216, 212.7515),
c(470.4070, 542.0758, 212.7369),
c(541.6032, 429.4569, 250.9978),
c(429.4120, 541.5583, 250.9528) )
# Final Output
position <- get_position.m(obs_dist = distances)
summary.m(position)
plot.m(result = position)
distances<- c(449.2136, 284.8427, 414.3106)
# Final Output
position <- get_position.m(obs_dist = distances)
summary.m(position)
plot.m(result = position)
starting_values <- c(10, 10, 10)
distances <- rbind( c(458.9474, 337.1013, 363.1112),
c(337.0894, 458.9355, 363.0993),
c(442.5835, 442.5835, 283.9493),
c(520.1845, 520.1845, 184.0449),
c(534.1411, 499.0299, 191.3455),
c(499.1322, 534.2434, 191.4479),
c(542.0904, 470.4216, 212.7515),
c(470.4070, 542.0758, 212.7369),
c(541.6032, 429.4569, 250.9978),
c(429.4120, 541.5583, 250.9528) )
# Final Output
position <- get_position.m(obs_dist = distances)
summary.m(position)
plot.m(result = position)
starting_values <- c(0, 0, 0)
distances <- rbind( c(458.9474, 337.1013, 363.1112),
c(337.0894, 458.9355, 363.0993),
c(442.5835, 442.5835, 283.9493),
c(520.1845, 520.1845, 184.0449),
c(534.1411, 499.0299, 191.3455),
c(499.1322, 534.2434, 191.4479),
c(542.0904, 470.4216, 212.7515),
c(470.4070, 542.0758, 212.7369),
c(541.6032, 429.4569, 250.9978),
c(429.4120, 541.5583, 250.9528) )
# Final Output
position <- get_position.m(obs_dist = distances)
summary.m(position)
plot.m(result = position)
starting_values <- c(0, 0, 0)
distances <- rbind( c(458.9474, 337.1013, 363.1112),
c(337.0894, 458.9355, 363.0993),
c(442.5835, 442.5835, 283.9493),
c(520.1845, 520.1845, 184.0449),
c(534.1411, 499.0299, 191.3455),
c(499.1322, 534.2434, 191.4479),
c(542.0904, 470.4216, 212.7515),
c(470.4070, 542.0758, 212.7369),
c(541.6032, 429.4569, 250.9978),
c(429.4120, 541.5583, 250.9528) )
# Final Output
position <- get_position.m(obs_dist = distances, starting_values = starting_values)
summary.m(position)
plot.m(result = position)
distances<- c(449.2136, 284.8427, 414.3106)
starting_values <- c(0, 0, 0)
# Final Output
position <- get_position.m(obs_dist = distances, starting_values = starting_values)
summary.m(position)
plot.m(result = position)
distances<- c(449.2136, 284.8427, 414.3106)
starting_values <- c(0, 0, 0)
# Final Output
position <- get_position.m(obs_dist = distances)
summary.m(position)
plot.m(result = position)
rm(list = ls())
# Estimation function Matrix
theta_hat.m <- function(x, y, obs_dist, par) {
theta.m = 0
for (i in 1:nrow(as.matrix(x))) {
theta.m = theta.m + ((x[i]-par[1])^2 + (y[i]-par[2])^2 - (obs_dist[i]-par[3])^2)^2
}
return(theta.m)
}
# Optimation function
get_position.m <- function(x = c(-300,300,0), y = c(300,300,-300), obs_dist, starting_values = c(0, 0, 0)) {
if (class(obs_dist) == "numeric") {
obs_dist <- t(as.matrix(obs_dist))
}
distances.l <- list()
for (i in 1:nrow(obs_dist)) {
distances.l[[i]] <- obs_dist[i,]
}
result.m <- list()
for (j in 1:nrow(obs_dist)) {
result.m[[j]] <- optim(par = starting_values, fn = theta_hat.m, x = x, y = y, obs_dist = distances.l[[j]])[1]
}
result.m <- unlist(result.m, recursive = F, use.names = F)
result.m <- t(as.data.frame(result.m))
result.m <- result.m[,-3]
if (class(result.m) == "numeric") {
invisible(result.m)
} else {
rownames(result.m) <- 1:nrow(result.m)
colnames(result.m) <- c("X", "Y")
invisible(result.m) # return value which can be assigned but don't print
}
}
# Summary function
summary.m <- function(result) {
if (class(result) == "numeric") {
cat("The estimated position is: \nX=", result[1], "\nY=", result[1])
} else {
cat("The estimated positions are: \n")
print(result)
}
}
# Plotting function
plot.m <- function(x = c(-300,300,0), y = c(300,300,-300),result) {
if (class(result) == "numeric") {
plot(x = x, y = y, pch=21, cex = 3, col = "black", bg = c("red", "green", "blue"), panel.first = grid(), asp = 1)
symbols(0,0, circles = 200, add = T, inches = F, bg = "grey")
points(x = result[1], y = result[2], pch = 4, col = "orange", lwd = 2, cex = 2)
} else {
plot(x = x, y = y, pch=21, cex = 3, col = "black", bg = c("red", "green", "blue"), panel.first = grid(), asp = 1)
symbols(0,0, circles = 200, add = T, inches = F, bg = "grey")
points(x = result[,1], y = result[,2], pch = 4, col = "orange", lwd = 2, cex = 2)
}
}
distances <- rbind( c(458.9474, 337.1013, 363.1112),
c(337.0894, 458.9355, 363.0993),
c(442.5835, 442.5835, 283.9493),
c(520.1845, 520.1845, 184.0449),
c(534.1411, 499.0299, 191.3455),
c(499.1322, 534.2434, 191.4479),
c(542.0904, 470.4216, 212.7515),
c(470.4070, 542.0758, 212.7369),
c(541.6032, 429.4569, 250.9978),
c(429.4120, 541.5583, 250.9528) )
# Final Output
position <- get_position.m(obs_dist = distances)
summary.m(position)
plot.m(result = position)
distances<- c(449.2136, 284.8427, 414.3106)
starting_values <- c(0, 0, 0)
# Final Output
position <- get_position.m(obs_dist = distances)
summary.m(position)
plot.m(result = position)
rm(list = ls())
distances <- c(449.2136, 284.8427, 414.3106)
# Estimation function
theta_hat <- function(x, y, obs_dist, par) {
theta = 0
for (i in 1:nrow(x)) {
theta = theta + ((x[i]-par[1])^2 + (y[i]-par[2])^2 - (obs_dist[i]-par[3])^2)^2
}
return(theta)
}
# Optimation function
get_position <- function(x = c(-300,300,0), y = c(300,300,-300), starting_values = c(0, 0, 0), obs_dist) {
result <- optim(par = starting_values, fn = theta_hat, x = x, y = y, obs_dist = obs_dist)[1]
result <- unlist(result)
names(result) <- NULL
result <- result[1:2]
invisible(result)
}
# Summary function
summary <- function(result) {
cat("The estimated position is: \nX=", result[1], "\nY=", result[1])
}
# Plotting function
`%plot%` <- function(x = c(-300,300,0), y = c(300,300,-300),result) {
plot(x = x, y = y, pch=21, cex = 3, col = "black", bg = c("red", "green", "blue"), panel.first = grid(), asp = 1)
symbols(0,0, circles = 200, add = T, inches = F, bg = "grey")
points(x = result[1], y = result[2], pch = 4, col = "orange", lwd = 2, cex = 2)
}
# Final Output
position <- get_position(obs_dist = distances)
rm(list = ls())
distances <- c(449.2136, 284.8427, 414.3106)
# Estimation function
theta_hat <- function(x, y, obs_dist, par) {
theta = 0
for (i in 1:nrow(as.matrix(x))) {
theta = theta + ((x[i]-par[1])^2 + (y[i]-par[2])^2 - (obs_dist[i]-par[3])^2)^2
}
return(theta)
}
# Optimation function
get_position <- function(x = c(-300,300,0), y = c(300,300,-300), starting_values = c(0, 0, 0), obs_dist) {
result <- optim(par = starting_values, fn = theta_hat, x = x, y = y, obs_dist = obs_dist)[1]
result <- unlist(result)
names(result) <- NULL
result <- result[1:2]
invisible(result)
}
# Summary function
summary <- function(result) {
cat("The estimated position is: \nX=", result[1], "\nY=", result[1])
}
# Plotting function
`%plot%` <- function(x = c(-300,300,0), y = c(300,300,-300),result) {
plot(x = x, y = y, pch=21, cex = 3, col = "black", bg = c("red", "green", "blue"), panel.first = grid(), asp = 1)
symbols(0,0, circles = 200, add = T, inches = F, bg = "grey")
points(x = result[1], y = result[2], pch = 4, col = "orange", lwd = 2, cex = 2)
}
# Final Output
position <- get_position(obs_dist = distances)
summary(position)
`%plot%`(result = position)
sq_area = 4
find_pi <- function(B = 5000, seed = 10, make_plot = FALSE){
# Control seed
set.seed(seed)
# Simulate B points
point = matrix(runif(2*B, -1, 1), nrow = B, ncol = 2)
circ = (point[,1])^2 + (point[,2])^2
z <- ifelse(circ <= 1, 1, 0)
hat_pi <- sq_area* (sum(z)/B)
if (make_plot == TRUE) {
plot(point[,1][which(circ<=1)],point[,2][which(circ<=1)],xlab="X",ylab="Y",main="Monte Carlo Pi simulation", col = 'cadetblue3')
points(point[,1][which(circ>1)],point[,2][which(circ>1)],col='coral2')
}
return(hat_pi)
}
find_pi(make_plot = TRUE) # default 5000 points and a graph
rm(list = ls())
distances <- c(449.2136, 284.8427, 414.3106)
# Estimation function
theta_hat <- function(x, y, obs_dist, par) {
theta = 0
for (i in 1:nrow(as.matrix(x))) {
theta = theta + ((x[i]-par[1])^2 + (y[i]-par[2])^2 - (obs_dist[i]-par[3])^2)^2
}
return(theta)
}
# Optimation function
get_position <- function(x = c(-300,300,0), y = c(300,300,-300), starting_values = c(0, 0, 0), obs_dist) {
result <- optim(par = starting_values, fn = theta_hat, x = x, y = y, obs_dist = obs_dist)[1]
result <- unlist(result)
names(result) <- NULL
result <- result[1:2]
invisible(result)
}
# Summary function
summary <- function(result) {
cat("The estimated position is: \nX=", result[1], "\nY=", result[1])
}
# Plotting function
plot <- function(x = c(-300,300,0), y = c(300,300,-300),result) {
plot(x = x, y = y, pch=21, cex = 3, col = "black", bg = c("red", "green", "blue"), panel.first = grid(), asp = 1)
symbols(0,0, circles = 200, add = T, inches = F, bg = "grey")
points(x = result[1], y = result[2], pch = 4, col = "orange", lwd = 2, cex = 2)
}
# Final Output
position <- get_position(obs_dist = distances)
summary(position)
plot(result = position)
rm(list = ls())
distances <- c(449.2136, 284.8427, 414.3106)
# Estimation function
theta_hat <- function(x, y, obs_dist, par) {
theta = 0
for (i in 1:nrow(as.matrix(x))) {
theta = theta + ((x[i]-par[1])^2 + (y[i]-par[2])^2 - (obs_dist[i]-par[3])^2)^2
}
return(theta)
}
# Optimation function
get_position <- function(x = c(-300,300,0), y = c(300,300,-300), starting_values = c(0, 0, 0), obs_dist) {
result <- optim(par = starting_values, fn = theta_hat, x = x, y = y, obs_dist = obs_dist)[1]
result <- unlist(result)
names(result) <- NULL
result <- result[1:2]
invisible(result)
}
# Summary function
summary <- function(result) {
cat("The estimated position is: \nX=", result[1], "\nY=", result[1])
}
# Plotting function
`%plot%` <- function(x = c(-300,300,0), y = c(300,300,-300),result) {
plot(x = x, y = y, pch=21, cex = 3, col = "black", bg = c("red", "green", "blue"), panel.first = grid(), asp = 1)
symbols(0,0, circles = 200, add = T, inches = F, bg = "grey")
points(x = result[1], y = result[2], pch = 4, col = "orange", lwd = 2, cex = 2)
}
# Final Output
position <- get_position(obs_dist = distances)
summary(position)
`%plot%`(result = position)
# Estimation function
theta_hat <- function(x, y, obs_dist, par) {
theta = 0
for (i in 1:nrow(as.matrix(x))) {
theta = theta + ((x[i]-par[1])^2 + (y[i]-par[2])^2 - (obs_dist[i]-par[3])^2)^2
}
return(theta)
}
# Optimation function
get_position <- function(x = c(-300,300,0), y = c(300,300,-300), starting_values = c(0, 0, 0), obs_dist) {
result <- optim(par = starting_values, fn = theta_hat, x = x, y = y, obs_dist = obs_dist)[1]
result <- unlist(result)
names(result) <- NULL
result <- result[1:2]
invisible(result)
}
# Summary function
summary <- function(result) {
cat("The estimated position is: \nX=", result[1], "\nY=", result[1])
}
# Plotting function
`%plot%` <- function(x = c(-300,300,0), y = c(300,300,-300),result) {# `% %` because plot is already reserved for the R base function plot()
plot(x = x, y = y, pch=21, cex = 3, col = "black", bg = c("red", "green", "blue"), panel.first = grid(), asp = 1)
symbols(0,0, circles = 200, add = T, inches = F, bg = "grey")
points(x = result[1], y = result[2], pch = 4, col = "orange", lwd = 2, cex = 2)
}
# Final Output
distances <- c(449.2136, 284.8427, 414.3106)
position <- get_position(obs_dist = distances)
summary(position)
`%plot%`(result = position)
rm(list=ls())
sq_area = 4
find_pi <- function(B = 5000, seed = 10, make_plot = FALSE){
# Control seed
set.seed(seed)
# Simulate B points
point = matrix(runif(2*B, -1, 1), nrow = B, ncol = 2)
circ = (point[,1])^2 + (point[,2])^2
z <- ifelse(circ <= 1, 1, 0)
hat_pi <- sq_area* (sum(z)/B)
if (make_plot == TRUE) {
plot(point[,1][which(circ<=1)],point[,2][which(circ<=1)],xlab="X",ylab="Y",main="Monte Carlo Pi simulation", col = 'cadetblue3')
points(point[,1][which(circ>1)],point[,2][which(circ>1)],col='coral2')
}
return(hat_pi)
}
find_pi(make_plot = TRUE) # default 5000 points and a graph
# Estimation function
theta_hat <- function(x, y, obs_dist, par) {
theta = 0
for (i in 1:nrow(as.matrix(x))) {
theta = theta + ((x[i]-par[1])^2 + (y[i]-par[2])^2 - (obs_dist[i]-par[3])^2)^2
}
return(theta)
}
# Optimation function
get_position <- function(x = c(-300,300,0), y = c(300,300,-300), starting_values = c(0, 0, 0), obs_dist) {
result <- optim(par = starting_values, fn = theta_hat, x = x, y = y, obs_dist = obs_dist)[1]
result <- unlist(result)
names(result) <- NULL
result <- result[1:2]
invisible(result)
}
# Summary function
summary <- function(result) {
cat("The estimated position is: \nX=", result[1], "\nY=", result[1])
}
# Plotting function
`%plot%` <- function(x = c(-300,300,0), y = c(300,300,-300),result) {# `% %` because plot is already reserved for the R base function plot()
plot(x = x, y = y, pch=21, cex = 3, col = "black", bg = c("red", "green", "blue"), panel.first = grid(), asp = 1)
symbols(0,0, circles = 200, add = T, inches = F, bg = "grey")
points(x = result[1], y = result[2], pch = 4, col = "orange", lwd = 2, cex = 2)
}
# Final Output
distances <- c(449.2136, 284.8427, 414.3106)
position <- get_position(obs_dist = distances)
summary(position)
`%plot%`(result = position)
# Estimation function Matrix
theta_hat.m <- function(x, y, obs_dist, par) {
theta.m = 0
for (i in 1:nrow(as.matrix(x))) {
theta.m = theta.m + ((x[i]-par[1])^2 + (y[i]-par[2])^2 - (obs_dist[i]-par[3])^2)^2
}
return(theta.m)
}
# Optimation function
get_position.m <- function(x = c(-300,300,0), y = c(300,300,-300), obs_dist, starting_values = c(0, 0, 0)) {
if (class(obs_dist) == "numeric") {
obs_dist <- t(as.matrix(obs_dist))
}
distances.l <- list()
for (i in 1:nrow(obs_dist)) {
distances.l[[i]] <- obs_dist[i,]
}
result.m <- list()
for (j in 1:nrow(obs_dist)) {
result.m[[j]] <- optim(par = starting_values, fn = theta_hat.m, x = x, y = y, obs_dist = distances.l[[j]])[1]
}
result.m <- unlist(result.m, recursive = F, use.names = F)
result.m <- t(as.data.frame(result.m))
result.m <- result.m[,-3]
if (class(result.m) == "numeric") {
invisible(result.m)
} else {
rownames(result.m) <- 1:nrow(result.m)
colnames(result.m) <- c("X", "Y")
invisible(result.m) # return values which can be assigned but don't print
}
}
# Summary function
summary.m <- function(result) {
if (class(result) == "numeric") {
cat("The estimated position is: \nX=", result[1], "\nY=", result[1])
} else {
cat("The estimated positions are: \n")
print(result)
}
}
# Plotting function
plot.m <- function(x = c(-300,300,0), y = c(300,300,-300),result) {
if (class(result) == "numeric") {
plot(x = x, y = y, pch=21, cex = 3, col = "black", bg = c("red", "green", "blue"), panel.first = grid(), asp = 1)
symbols(0,0, circles = 200, add = T, inches = F, bg = "grey")
points(x = result[1], y = result[2], pch = 4, col = "orange", lwd = 2, cex = 2)
} else {
plot(x = x, y = y, pch=21, cex = 3, col = "black", bg = c("red", "green", "blue"), panel.first = grid(), asp = 1)
symbols(0,0, circles = 200, add = T, inches = F, bg = "grey")
points(x = result[,1], y = result[,2], pch = 4, col = "orange", lwd = 2, cex = 2)
}
}
distances<- c(449.2136, 284.8427, 414.3106)
# Final Output
position <- get_position.m(obs_dist = distances)
summary.m(position)
plot.m(result = position)
distances <- rbind( c(458.9474, 337.1013, 363.1112),
c(337.0894, 458.9355, 363.0993),
c(442.5835, 442.5835, 283.9493),
c(520.1845, 520.1845, 184.0449),
c(534.1411, 499.0299, 191.3455),
c(499.1322, 534.2434, 191.4479),
c(542.0904, 470.4216, 212.7515),
c(470.4070, 542.0758, 212.7369),
c(541.6032, 429.4569, 250.9978),
c(429.4120, 541.5583, 250.9528) )
# Final Output
position <- get_position.m(obs_dist = distances)
summary.m(position)
plot.m(result = position)
plot
as.matrix
invisible
Primitive("invisible")
.Primitive("invisible")
rm(list = ls())
plot(1)
library("graphics")
plot(1)
plot(1)
plot(1,type=p)
plot(1,type="p")
plot(1,type="n")
scatter.smooth(1)
scatter.smooth(1:1000)
scatter.smooth(1:10)
sum(1:2)
scatter.smooth(1:10)
plot(1)
plot.default(1)
plot(1)
plot(1)
plot(1)
plot.default(1)
# Calculate annual standard deviation
yearlystd <- function(backtest){
portfoliologreturns <- data.frame()
for(r in 1:(nrow(backtest)-1)){
portfoliologreturns[r,1] <- log(backtest[r+1,1]/backtest[r,1])
}
yearlystd <- sd(portfoliologreturns[,1])*sqrt(252)
return(yearlystd)
}
load("mydf.RData")
setwd("~/Documents/GitHub/Group2_Project/GryffindorRoboAdvisor")
load("mydf.RData")
yearlystd(mydf)
yearlystd(mydf$SP)
yearlystd(mydf$SP_Utilities)
