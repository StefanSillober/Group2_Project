for (r in 1:nrow(equity)){
portfolio[r, 1] <- equity[r, 1] * equityaspercent +
debt[r, 1] * (1 - equityaspercent)
}
return(portfolio)
}
indexpf <- function(data) {
returns <- data.frame()
for (c in 1:ncol(data)) {
for (r in 1:nrow(data) - 1) {
returns[r, c] <- (data[r + 1, c] - data[r, c]) / data[r, c]
}
}
indexportfolio <- data.frame()
for (c in 1:ncol(data)) {
indexportfolio[1, c] <- 100
}
for (c in 1:ncol(data)){
for (r in 1:nrow(returns)){
indexportfolio[r + 1,c] <- indexportfolio[r, c] *
(1 + returns[r , c])
}
}
return(indexportfolio)
}
###---###---###---###---###---###---###---###---###---###---###---###---###
##---Test Functions for Markdown file---##
nicegraph <- function(x=1000) {
plot(sin(1:x), cos(1:x))
}
piechart <- function(x=c(0.3,0.2,0.1,0.4)) {
pie(x)
}
randperform <- function(x=cumsum(rnorm(1000,1,5))) {
plot(x)
}
testplot <- function(x) {
plot(x)
}
### Risk Parity Portfolio ######################################################
################################################################################
riskparity <- function(covmatrix, par) {
par <- as.matrix(par)
par <- rbind(par, 1 - sum(par[, 1]))
startingweights <- par
marginalrisk <- covmatrix %*% startingweights
contribution <- as.matrix(as.numeric((startingweights * marginalrisk))) /
sqrt(as.numeric((t(startingweights) %*% covmatrix %*% startingweights)))
portfoliorisk <- sqrt(as.numeric((t(startingweights) %*% covmatrix %*%
startingweights)))
contributionpercent <- matrix(ncol = 1, nrow = 3)
for (r in 1:nrow(contribution)) {
contributionpercent[r, 1] <- contribution[r, 1]/sum(contribution)
}
###### Workaround to make the optimizer find a stable minimum ##################
if (par[1, 1] + par[2, 1] > 1){
portfoliorisk <- 3
}
portfoliorisk <- abs((contributionpercent[1, 1] -
contributionpercent[2, 1])) +
abs((contributionpercent[1, 1] -
contributionpercent[3, 1]))
return(portfoliorisk)
}
riskparitypf <- function(equity, debt, commodity) {
data <- as.matrix(cbind(equity, debt, commodity))
startingweights <- as.matrix(rep(1 / ncol(data),
length.out = (ncol(data) - 1)))
returns <- data.frame()
for (c in 1:ncol(data)) {
for (r in 1:nrow(data) - 1) {
returns[r, c] <- (data[r + 1, c] - data[r, c]) / data[r, c]
}
}
returnmatrix <- as.matrix(returns[, ])
covmatrix <- cov(returnmatrix)
optweights <- optim(par = as.vector(startingweights),
fn = riskparity,
covmatrix = covmatrix,
lower = 0,
method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
optweights <- rbind(optweights, 1 - sum(optweights))
portfolio <- data.frame(100)
for (r in 1:nrow(returns)) {
portfolio[(1 + r), 1] <- portfolio[r, 1] *
(1 + (returns[r, 1] * optweights[1, 1] +
returns[r, 2] * optweights[2, 1] +
returns[r, 3] * optweights[3, 1]))
}
return(portfolio)
##### end of Risk parity function ##############################################
}
##### Minimum Variance Portfolio ###############################################
################################################################################
minvar <- function(covmatrix,par) {
par <- as.matrix(par)
par <- rbind(par, 1 - sum(par[, 1]))
std <- t(par) %*% covmatrix %*% par
if (par[1, 1] + par[2, 1] > 1){
std <- 3
}
return(std)
}
minvarpf <- function(data) {
returns <- data.frame()
for (c in 1:ncol(data)) {
for (r in 1:nrow(data) - 1) {
returns[r, c] <- (data[(r + 1), c] - data[r, c]) / data[r, c]
}
}
returnmatrix <- as.matrix(returns[, ])
covmatrix <- as.matrix(cov(returnmatrix))
startingweights <- as.matrix(rep(1 / ncol(data),
length.out = (ncol(data) - 1)))
optweights <- optim(par = as.vector(startingweights),
fn = minvar,
covmatrix = covmatrix,
lower = 0,
method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
optweights <- rbind(optweights, 1 - sum(optweights))
portfolio <- data.frame(100)
for (r in 1:nrow(returns)) {
portfolio[(1 + r), 1] <- portfolio[r, 1] *
(1 + (as.matrix(returns[r, ]) %*% optweights))
}
return(portfolio)
### End of Minimum Variance Portfolio function #################################
}
##### Dataspliting and optimizing###############################################
################################################################################
datasplit <- function(subdata,updateProgress = NULL){
flor <- floor(ncol(subdata) / 15)
remaining <- ncol(subdata) - 15 * flor
lastdata <- flor + 1
for (n in 1:flor){
data.n  <- subdata[((n - 1) * 15 + 1):(n * 15)]
assign(as.character(paste("data", as.character(n), sep = "")), data.n)
}
data.lastdata <- subdata[(flor * 15):ncol(subdata)]
assign(as.character(paste("data", as.character((flor + 1)), sep="")),
data.lastdata)
finaldata <- data.frame(matrix(nrow = nrow(subdata)))[, -1]
new_row <- data.frame(x = rnorm(1), y = rnorm(1))
for (n in 1:(flor + 1)){
dataopt<- minvarpf(get(paste("data", n, sep = "")))
assign(as.character(paste("dataopt", as.character(n), sep="")), dataopt)
if (is.function(updateProgress)) {
text <- "Pleas don't turn off your Computer"
updateProgress(detail = text)
}
finaldata <- cbind(finaldata,dataopt)
}
return(finaldata)
### End of Dataspliting function #################################
}
### call the portfolios according to the user's input ##########################
################################################################################
##### short bond only ##########################################################
output$ourPF <- renderPlot({
# Create the Progress object
progress <- shiny::Progress$new()
progress$set(message = "Calculating Optimal Portfolio", value = 0)
# Close the progress when this reactive exits (even if there's an error)
on.exit(progress$close())
updateProgress <- function(value = NULL, detail = NULL) {
if (is.null(value)) {
value <- progress$getValue()
value <- value + (progress$getMax() - value) / 3
}
progress$set(value = value, detail = detail)
}
if (input$rpref2 == 1 && input$inv_horizon <= 5) {
portfoliofinal <<- shortbond
plot.ts(portfoliofinal)
title("short bond")
summary(shortbond)
}
##### long bond only ###########################################################
if ((input$rpref2 == 2 && input$inv_horizon <= 5) ||
(input$rpref2 == 1 && input$inv_horizon > 5 &&
input$inv_horizon <= 10)) {
portfoliofinal <<- longbond
equityinvestment <<- 0
plot.ts(portfoliofinal)
title("long bond")
}
##### minimum variance PF ######################################################
if ((input$rpref2 == 3 && input$inv_horizon <= 5) ||
#redundant but included so that the number of conitions = number of PFs
(input$rpref2 == 3 && input$inv_horizon > 5 &&
input$inv_horizon <= 10) ||
(input$rpref2 == 2 && input$inv_horizon > 10)) {
####### split the required input df into sub-df's to make them optimizable #####
finaldata <- datasplit(newData(),updateProgress)
portfoliofinal <<- minvarpf(finaldata)
equityinvestment <<- 0
####### include the performance plot in Shiny ##################################
plot.ts(portfoliofinal)
title("minimum variance portfolio")
}
###### Equity + longbond overweight bond #######################################
if (input$rpref2 == 1 && input$inv_horizon > 10) {
finaldata <- datasplit(newData(),updateProgress)
finalpf <- optimpf(finaldata)
longbondindexed <- indexpf(as.data.frame(longbond))
portfoliofinal <<- equityanddeptpf(finalpf, longbondindexed, 0.2)
plot.ts(as.matrix(portfoliofinal))
title("Equity-Longbond Bond overweight")
equityinvestment <<- 0.2
}
######################### risk parity ############################
if ((input$rpref2 == 4 && input$inv_horizon <= 5) ||
(input$rpref2 == 5 && input$inv_horizon <= 5) ||
(input$rpref2 == 4 && input$inv_horizon > 5 && input$inv_horizon <= 10) ||
(input$rpref2 == 5 && input$inv_horizon > 5 && input$inv_horizon <= 10) ||
(input$rpref2 == 3 && input$inv_horizon > 10) ||
(input$rpref2 == 4 && input$inv_horizon > 10)) {
finaldata <- datasplit(newData(),updateProgress)
finalpf <- optimpf(finaldata)
longbonddf <- as.data.frame(longbond)
commoditydf <- as.data.frame(commodities)
portfoliofinal <<- riskparitypf(finalpf, longbonddf, commoditydf)
equityinvestment <<- 0
plot.ts(portfoliofinal)
title("Risk Parity")
}
########################### equity + longbond overweight equity ########
if ((input$rpref2 == 6 && input$inv_horizon <= 5) ||
(input$rpref2 == 6 && input$inv_horizon > 5 && input$inv_horizon <= 10) ||
(input$rpref2 == 5 && input$inv_horizon > 10)) {
finaldata <- datasplit(newData(),updateProgress)
finalpf <- optimpf(finaldata)
longbondindexed <- indexpf(as.data.frame(longbond))
portfoliofinal <<- equityanddeptpf(finalpf, longbondindexed, 0.8)
equityinvestment <<- 0.8
plot.ts(as.matrix(portfoliofinal))
title("Equity-Bond Equity overweight")
}
########################## Pure EquityÂ² #########################
if ((input$rpref2 == 6 && input$inv_horizon > 10) ||
(input$rpref2 == 7 && input$inv_horizon <= 5) ||
(input$rpref2 == 7 && input$inv_horizon > 5 && input$inv_horizon <= 10) ||
(input$rpref2 == 7 && input$inv_horizon > 10)) {
finaldata <- datasplit(newData(),updateProgress)
portfoliofinal <<- optimpf(finaldata)
equityinvestment <<- 1
plot.ts(as.matrix(portfoliofinal))
title("Pure Equity")
}
})
### PDF Download Handler - option for the user to downloas her personal report #
output$downloadReport <- downloadHandler(
filename <- function() {
paste("my-report",
sep = '.',
switch(input$format,
PDF = "pdf",
HTML = "html",
Word = "docx")
)
},
content <- function(file) {
src <- normalizePath("report.Rmd")
####### temporarily switch to the temp dir, in case you do not have write ######
####### permission to the current working directory ############################
owd <- setwd(tempdir())
on.exit(setwd(owd))
file.copy(src,
"report.Rmd",
overwrite = TRUE)
out <- render('report.Rmd',
switch(input$format,
PDF = pdf_document(),
HTML = html_document(),
Word = word_document())
)
file.rename(out, file)
}
)
#### ValueBoxes ################################################################
################################################################################
### Boxes for Final Output Page ################################################
output$expectedValue <- renderValueBox({
valueBox(
paste0(round((1+(averagereturn(portfoliofinal)*input$inv_horizon)*input$initial_wealth)), "$"),
paste0("Expected wealth after ", input$inv_horizon, "years" ),
icon = icon("hand-holding-usd"),
color = "blue"
)
})
output$yearlygain <- renderValueBox({
valueBox(
paste0(round((averagereturn(portfoliofinal)*100)), "%"),
"Expected yearly gain",
icon = icon("chart-line"),
color = "green"
)
})
output$maxdrawdown <- renderValueBox({
valueBox(
paste0(round((maxdrawdown(portfoliofinal)*100)), "%"),
"Maxdrawdown",
icon = icon("greater-than"),
color = "red"
)
})
output$std <- renderValueBox({
valueBox(
paste0(round((yearlystd(portfoliofinal)*100)), "%"),
"Standarddeviation",
icon = icon("square-root-alt"),
color = "yellow"
)
})
output$sharpe <- renderValueBox({
valueBox(
round((averagereturn(portfoliofinal)/yearlystd(portfoliofinal)),2),
"Sharpe Ratio",
icon = icon("hourglass-half"),
color = "orange"
)
})
output$equity <- renderValueBox({
valueBox(
paste0(round(equityinvestment*100), "%"),
"Invested in Equity",
icon = icon("hand-holding-usd"),
color = "purple"
)
})
################################################################################
output$horizonBox <- renderValueBox({
valueBox(
paste0(input$inv_horizon, " years"),
"Investment Horizon",
icon = icon("hourglass-half"),
color = "blue"
)
})
output$returnBox <- renderValueBox({
valueBox(
paste0(drift[input$rpref] * 100, "%"),
"Return",
icon = icon("chart-line"),
color = "green"
)
})
output$stdBox <- renderValueBox({
valueBox(
paste0(diffusion[input$rpref] * 100, "%"),
"Standard Deviation",
icon = icon("square-root-alt"),
color = "red"
)
})
output$avgBox <- renderValueBox({
if (sum(sim$data) == 0) {
valueBox(
paste0(NA, "$"),
"Average Value",
icon = icon("hand-holding-usd"),
color = "blue"
)
} else {
valueBox(
paste0(round(mean(sim$data)), "$"),
"Average Value",
icon = icon("hand-holding-usd"),
color = "blue"
)
}
})
output$uplimBox <- renderValueBox({
if (sum(sim$data) == 0) {
valueBox(
paste0(NA, "$"),
"90% Limit Profit",
icon = icon("greater-than"),
color = "green"
)
} else {
valueBox(
paste0(round(sim$data[order(sim$data)[length(sim$data) * 0.9]] -
input$initial_wealth), "$"),
"90% Limit Profit",
icon = icon("greater-than"),
color = "green"
)
}
})
output$lowlimBox <- renderValueBox({
if (sum(sim$data) == 0) {
valueBox(
paste0(NA, "$"),
"10% Limit Loss",
icon = icon("less-than"),
color = "red"
)
} else {
valueBox(
paste0(round(sim$data[order(sim$data)[length(sim$data) * 0.1]] -
input$initial_wealth), "$"),
"10% Limit Loss",
icon = icon("less-than"),
color = "red"
)
}
})
output$horizonBox1 <- renderValueBox({
valueBox(
paste0(input$inv_horizon, " years"),
"Investment Horizon",
icon = icon("hourglass-half"),
color = "blue"
)
})
output$returnBox1 <- renderValueBox({
valueBox(
paste0(drift[input$rpref2] * 100, "%"),
"Return",
icon = icon("chart-line"),
color = "green"
)
})
output$stdBox1 <- renderValueBox({
valueBox(
paste0(diffusion[input$rpref2] * 100, "%"),
"Standard Deviation",
icon = icon("square-root-alt"),
color = "red"
)
})
output$avgBox1 <- renderValueBox({
valueBox(
paste0(round(mean(sim$terminal_wealth)), "$"),
"Average Value",
icon = icon("hand-holding-usd"),
color = "blue"
)
})
output$uplimBox1 <- renderValueBox({
valueBox( ############ the following line is supposed to be too long ;-)
paste0(round(sim$terminal_wealth[order(sim$terminal_wealth)[draws * 0.9]] -
input$initial_wealth), "$"),
"90% Limit Profit",
icon = icon("greater-than"),
color = "green"
)
})
output$lowlimBox1 <- renderValueBox({
valueBox( ############ the following line is supposed to be too long ;-)
paste0(round(sim$terminal_wealth[order(sim$terminal_wealth)[draws * 0.1]] -
input$initial_wealth), "$"),
"10% Limit Loss",
icon = icon("less-than"),
color = "red"
)
})
#### Switch Buttons ############################################################
################################################################################
### Switch Tabs with action buttons ############################################
observeEvent(
input$button1, {
newtab <- switch(input$tabs, "tab1" = "tab2")
updateTabItems(session, "tabs", newtab)
}
)
observeEvent(
input$button2, {
newtab <- switch(input$tabs, "tab2" = "tab1")
updateTabItems(session, "tabs", newtab)
}
)
observeEvent(
input$button3, {
newtab <- switch(input$tabs, "tab2" = "tab3")
updateTabItems(session, "tabs", newtab)
}
)
observeEvent(
input$button4, {
newtab <- switch(input$tabs, "tab3" = "tab2")
updateTabItems(session, "tabs", newtab)
}
)
observeEvent( # include error message, when all regions are deselected #####
input$button5, {
if (is.null(input$mymap_groups)) {
sendSweetAlert(
session = session,
title = "Error Message",
text = "Please select at least one region!",
type = "error"
)
} else {
newtab <- switch(input$tabs, "tab3" = "tab4")
updateTabItems(session, "tabs", newtab)
}
}
)
observeEvent(
input$button6, {
newtab <- switch(input$tabs, "tab4" = "tab3")
updateTabItems(session, "tabs", newtab)
}
)
# end of server function #######################################################
################################################################################
}
runApp(shinyApp(ui,server),launch.browser = TRUE)
