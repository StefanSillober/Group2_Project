expectedreturn <- as.matrix(rep(0,length.out=ncol(data)))
#return and covariances as matrixes
returnmatrix <- as.matrix(returns[,])
covmatrix <- cov(returnmatrix)
#expected returns for every stock
for(c in 1:ncol(returns)){
expectedreturn[c,1] <- mean(returns[,c])
}
#Find Optimal portfolioweights
optweights <- optim(par = as.vector(startingweights), fn = sharpe,
expectedreturn = expectedreturn, covmatrix = covmatrix ,
control=list(fnscale=-1),lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
#Indexed Portfolio
indexportfolio <- data.frame()
for(c in 1:ncol(data)){
indexportfolio[1,c] <- 100
}
for(c in 1:ncol(data)){
for(r in 1:nrow(returns)){
indexportfolio[r+1,c] <- indexportfolio[r,c]*(1+returns[r,c])
}
}
colnames(indexportfolio) <- NULL
rownames(indexportfolio) <- NULL
test <- as.matrix(indexportfolio[1,])
portfolio <- data.frame()
#for(r in 1:nrow(indexportfolio)){
#    portfolio[r,1] <- as.matrix(indexportfolio[r,]) %*% optweights
#}
return(expectedreturn)
}
expectedreturn <- opt(finaldata)
expectedreturn
sharpe(expectedreturn = expectedreturn, covmatrix = covmatrix, par = c(0.1,0.1,0.1,0.1,0.1,0.1))
# Calculate sharpe Ratio for maximization
sharpe <- function(expectedreturn, covmatrix, par){
par <- as.matrix(par)
par <- rbind(par, 1-sum(par[,1]))
pfreturn <- t(expectedreturn) %*% as.matrix(par)
pfvar <- t(as.matrix(par)) %*% covmatrix %*% as.matrix(par)
sharperatio <- pfreturn/(pfvar^0.5)
return(par)
}
sharpe(expectedreturn = expectedreturn, covmatrix = covmatrix, par = c(0.1,0.1,0.1,0.1,0.1,0.1))
# Calculate sharpe Ratio for maximization
sharpe <- function(expectedreturn, covmatrix, par){
par <- as.matrix(par)
par <- rbind(par, 1-sum(par[,1]))
pfreturn <- t(expectedreturn) %*% as.matrix(par)
pfvar <- t(as.matrix(par)) %*% covmatrix %*% as.matrix(par)
sharperatio <- pfreturn/(pfvar^0.5)
return(sharperatio)
}
### Sharperatio optimized pure Equity Portfolio
# Takes a dataframe with all final data as input
opt <- function(data){
#get past returns
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data)-1){
returns[r,c] <- (data[r+1,c]-data[r,c])/data[r,c]
}
}
#startingweights for optimisation
startingweights <- as.matrix(rep(1/ncol(data),length.out=(ncol(data)-1)))
expectedreturn <- as.matrix(rep(0,length.out=ncol(data)))
#return and covariances as matrixes
returnmatrix <- as.matrix(returns[,])
covmatrix <- cov(returnmatrix)
#expected returns for every stock
for(c in 1:ncol(returns)){
expectedreturn[c,1] <- mean(returns[,c])
}
#Find Optimal portfolioweights
optweights <- optim(par = as.vector(startingweights), fn = sharpe,
expectedreturn = expectedreturn, covmatrix = covmatrix ,
control=list(fnscale=-1),lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
#Indexed Portfolio
indexportfolio <- data.frame()
for(c in 1:ncol(data)){
indexportfolio[1,c] <- 100
}
for(c in 1:ncol(data)){
for(r in 1:nrow(returns)){
indexportfolio[r+1,c] <- indexportfolio[r,c]*(1+returns[r,c])
}
}
colnames(indexportfolio) <- NULL
rownames(indexportfolio) <- NULL
test <- as.matrix(indexportfolio[1,])
portfolio <- data.frame()
#for(r in 1:nrow(indexportfolio)){
#    portfolio[r,1] <- as.matrix(indexportfolio[r,]) %*% optweights
#}
return(expectedreturn)
}
### Sharperatio optimized pure Equity Portfolio
# Takes a dataframe with all final data as input
opt <- function(data){
#get past returns
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data)-1){
returns[r,c] <- (data[r+1,c]-data[r,c])/data[r,c]
}
}
#startingweights for optimisation
startingweights <- as.matrix(rep(1/ncol(data),length.out=(ncol(data)-1)))
expectedreturn <- as.matrix(rep(0,length.out=ncol(data)))
#return and covariances as matrixes
returnmatrix <- as.matrix(returns[,])
covmatrix <- cov(returnmatrix)
#expected returns for every stock
for(c in 1:ncol(returns)){
expectedreturn[c,1] <- mean(returns[,c])
}
#Find Optimal portfolioweights
optweights <- optim(par = as.vector(startingweights), fn = sharpe,
expectedreturn = expectedreturn, covmatrix = covmatrix ,
control=list(fnscale=-1),lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
#Indexed Portfolio
indexportfolio <- data.frame()
for(c in 1:ncol(data)){
indexportfolio[1,c] <- 100
}
for(c in 1:ncol(data)){
for(r in 1:nrow(returns)){
indexportfolio[r+1,c] <- indexportfolio[r,c]*(1+returns[r,c])
}
}
colnames(indexportfolio) <- NULL
rownames(indexportfolio) <- NULL
test <- as.matrix(indexportfolio[1,])
portfolio <- data.frame()
#for(r in 1:nrow(indexportfolio)){
#    portfolio[r,1] <- as.matrix(indexportfolio[r,]) %*% optweights
#}
return(optweights)
}
opt(finaldata)
### Sharperatio optimized pure Equity Portfolio
# Takes a dataframe with all final data as input
opt <- function(data){
#get past returns
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data)-1){
returns[r,c] <- (data[r+1,c]-data[r,c])/data[r,c]
}
}
#startingweights for optimisation
startingweights <- as.matrix(rep(1/ncol(data),length.out=(ncol(data)-1)))
expectedreturn <- as.matrix(rep(0,length.out=ncol(data)))
#return and covariances as matrixes
returnmatrix <- as.matrix(returns[,])
covmatrix <- cov(returnmatrix)
#expected returns for every stock
for(c in 1:ncol(returns)){
expectedreturn[c,1] <- mean(returns[,c])
}
#Find Optimal portfolioweights
optweights <- optim(par = as.vector(startingweights), fn = sharpe,
expectedreturn = expectedreturn, covmatrix = covmatrix ,
control=list(fnscale=-1),lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
rbind(optweights, 1-sum(optweights))
#Indexed Portfolio
indexportfolio <- data.frame()
for(c in 1:ncol(data)){
indexportfolio[1,c] <- 100
}
for(c in 1:ncol(data)){
for(r in 1:nrow(returns)){
indexportfolio[r+1,c] <- indexportfolio[r,c]*(1+returns[r,c])
}
}
colnames(indexportfolio) <- NULL
rownames(indexportfolio) <- NULL
test <- as.matrix(indexportfolio[1,])
portfolio <- data.frame()
#for(r in 1:nrow(indexportfolio)){
#    portfolio[r,1] <- as.matrix(indexportfolio[r,]) %*% optweights
#}
return(optweights)
}
opt(finaldata)
### Sharperatio optimized pure Equity Portfolio
# Takes a dataframe with all final data as input
opt <- function(data){
#get past returns
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data)-1){
returns[r,c] <- (data[r+1,c]-data[r,c])/data[r,c]
}
}
#startingweights for optimisation
startingweights <- as.matrix(rep(1/ncol(data),length.out=(ncol(data)-1)))
expectedreturn <- as.matrix(rep(0,length.out=ncol(data)))
#return and covariances as matrixes
returnmatrix <- as.matrix(returns[,])
covmatrix <- cov(returnmatrix)
#expected returns for every stock
for(c in 1:ncol(returns)){
expectedreturn[c,1] <- mean(returns[,c])
}
#Find Optimal portfolioweights
optweights <- optim(par = as.vector(startingweights), fn = sharpe,
expectedreturn = expectedreturn, covmatrix = covmatrix ,
control=list(fnscale=-1),lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
optweights <- rbind(optweights, 1-sum(optweights))
#Indexed Portfolio
indexportfolio <- data.frame()
for(c in 1:ncol(data)){
indexportfolio[1,c] <- 100
}
for(c in 1:ncol(data)){
for(r in 1:nrow(returns)){
indexportfolio[r+1,c] <- indexportfolio[r,c]*(1+returns[r,c])
}
}
colnames(indexportfolio) <- NULL
rownames(indexportfolio) <- NULL
test <- as.matrix(indexportfolio[1,])
portfolio <- data.frame()
#for(r in 1:nrow(indexportfolio)){
#    portfolio[r,1] <- as.matrix(indexportfolio[r,]) %*% optweights
#}
return(optweights)
}
opt(finaldata)
### Sharperatio optimized pure Equity Portfolio
# Takes a dataframe with all final data as input
opt <- function(data){
#get past returns
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data)-1){
returns[r,c] <- (data[r+1,c]-data[r,c])/data[r,c]
}
}
#startingweights for optimisation
startingweights <- as.matrix(rep(1/ncol(data),length.out=(ncol(data)-1)))
expectedreturn <- as.matrix(rep(0,length.out=ncol(data)))
#return and covariances as matrixes
returnmatrix <- as.matrix(returns[,])
covmatrix <- cov(returnmatrix)
#expected returns for every stock
for(c in 1:ncol(returns)){
expectedreturn[c,1] <- mean(returns[,c])
}
#Find Optimal portfolioweights
optweights <- optim(par = as.vector(startingweights), fn = sharpe,
expectedreturn = expectedreturn, covmatrix = covmatrix ,
control=list(fnscale=-1),lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
test <- sharpe(expectedreturn = expectedreturn, covmatrix = covmatrix, par = startingweights)
optweights <- rbind(optweights, 1-sum(optweights))
#Indexed Portfolio
indexportfolio <- data.frame()
for(c in 1:ncol(data)){
indexportfolio[1,c] <- 100
}
for(c in 1:ncol(data)){
for(r in 1:nrow(returns)){
indexportfolio[r+1,c] <- indexportfolio[r,c]*(1+returns[r,c])
}
}
colnames(indexportfolio) <- NULL
rownames(indexportfolio) <- NULL
test <- as.matrix(indexportfolio[1,])
portfolio <- data.frame()
#for(r in 1:nrow(indexportfolio)){
#    portfolio[r,1] <- as.matrix(indexportfolio[r,]) %*% optweights
#}
return(test)
}
opt(finaldata)
### Sharperatio optimized pure Equity Portfolio
# Takes a dataframe with all final data as input
opt <- function(data){
#get past returns
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data)-1){
returns[r,c] <- (data[r+1,c]-data[r,c])/data[r,c]
}
}
#startingweights for optimisation
startingweights <- as.matrix(rep(1/ncol(data),length.out=(ncol(data)-1)))
expectedreturn <- as.matrix(rep(0,length.out=ncol(data)))
#return and covariances as matrixes
returnmatrix <- as.matrix(returns[,])
covmatrix <- cov(returnmatrix)
#expected returns for every stock
for(c in 1:ncol(returns)){
expectedreturn[c,1] <- mean(returns[,c])
}
#Find Optimal portfolioweights
optweights <- optim(par = as.vector(startingweights), fn = sharpe,
expectedreturn = expectedreturn, covmatrix = covmatrix ,
control=list(fnscale=-1),lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
test <- sharpe(expectedreturn = expectedreturn, covmatrix = covmatrix, par = startingweights)
optweights <- rbind(optweights, 1-sum(optweights))
#Indexed Portfolio
indexportfolio <- data.frame()
for(c in 1:ncol(data)){
indexportfolio[1,c] <- 100
}
for(c in 1:ncol(data)){
for(r in 1:nrow(returns)){
indexportfolio[r+1,c] <- indexportfolio[r,c]*(1+returns[r,c])
}
}
colnames(indexportfolio) <- NULL
rownames(indexportfolio) <- NULL
#test <- as.matrix(indexportfolio[1,])
portfolio <- data.frame()
#for(r in 1:nrow(indexportfolio)){
#    portfolio[r,1] <- as.matrix(indexportfolio[r,]) %*% optweights
#}
return(test)
}
opt(finaldata)
### Sharperatio optimized pure Equity Portfolio
# Takes a dataframe with all final data as input
opt <- function(data){
#get past returns
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data)-1){
returns[r,c] <- (data[r+1,c]-data[r,c])/data[r,c]
}
}
#startingweights for optimisation
startingweights <- as.matrix(rep(1/ncol(data),length.out=(ncol(data)-1)))
expectedreturn <- as.matrix(rep(0,length.out=ncol(data)))
#return and covariances as matrixes
returnmatrix <- as.matrix(returns[,])
covmatrix <- cov(returnmatrix)
#expected returns for every stock
for(c in 1:ncol(returns)){
expectedreturn[c,1] <- mean(returns[,c])
}
#Find Optimal portfolioweights
optweights <- optim(par = as.vector(startingweights), fn = sharpe,
expectedreturn = expectedreturn, covmatrix = covmatrix ,
control=list(fnscale=-1),lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
test <- sharpe(expectedreturn = expectedreturn, covmatrix = covmatrix, par = optweights)
optweights <- rbind(optweights, 1-sum(optweights))
#Indexed Portfolio
indexportfolio <- data.frame()
for(c in 1:ncol(data)){
indexportfolio[1,c] <- 100
}
for(c in 1:ncol(data)){
for(r in 1:nrow(returns)){
indexportfolio[r+1,c] <- indexportfolio[r,c]*(1+returns[r,c])
}
}
colnames(indexportfolio) <- NULL
rownames(indexportfolio) <- NULL
#test <- as.matrix(indexportfolio[1,])
portfolio <- data.frame()
#for(r in 1:nrow(indexportfolio)){
#    portfolio[r,1] <- as.matrix(indexportfolio[r,]) %*% optweights
#}
return(test)
}
opt(finaldata)
### Sharperatio optimized pure Equity Portfolio
# Takes a dataframe with all final data as input
opt <- function(data){
#get past returns
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data)-1){
returns[r,c] <- (data[r+1,c]-data[r,c])/data[r,c]
}
}
#startingweights for optimisation
startingweights <- as.matrix(rep(1/ncol(data),length.out=(ncol(data)-1)))
expectedreturn <- as.matrix(rep(0,length.out=ncol(data)))
#return and covariances as matrixes
returnmatrix <- as.matrix(returns[,])
covmatrix <- cov(returnmatrix)
#expected returns for every stock
for(c in 1:ncol(returns)){
expectedreturn[c,1] <- mean(returns[,c])
}
#Find Optimal portfolioweights
optweights <- optim(par = as.vector(startingweights), fn = sharpe,
expectedreturn = expectedreturn, covmatrix = covmatrix ,
control=list(fnscale=-1),lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
optweights <- rbind(optweights, 1-sum(optweights))
#Indexed Portfolio
indexportfolio <- data.frame()
for(c in 1:ncol(data)){
indexportfolio[1,c] <- 100
}
for(c in 1:ncol(data)){
for(r in 1:nrow(returns)){
indexportfolio[r+1,c] <- indexportfolio[r,c]*(1+returns[r,c])
}
}
colnames(indexportfolio) <- NULL
rownames(indexportfolio) <- NULL
#test <- as.matrix(indexportfolio[1,])
portfolio <- data.frame()
for(r in 1:nrow(indexportfolio)){
portfolio[r,1] <- as.matrix(indexportfolio[r,]) %*% optweights
}
return(portfolio)
}
opt(finaldata)
### Sharperatio optimized pure Equity Portfolio
# Takes a dataframe with all final data as input
opt <- function(data){
#get past returns
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data)-1){
returns[r,c] <- (data[r+1,c]-data[r,c])/data[r,c]
}
}
#startingweights for optimisation
startingweights <- as.matrix(rep(1/ncol(data),length.out=(ncol(data)-1)))
expectedreturn <- as.matrix(rep(0,length.out=ncol(data)))
#return and covariances as matrixes
returnmatrix <- as.matrix(returns[,])
covmatrix <- cov(returnmatrix)
#expected returns for every stock
for(c in 1:ncol(returns)){
expectedreturn[c,1] <- mean(returns[,c])
}
#Find Optimal portfolioweights
optweights <- optim(par = as.vector(startingweights), fn = sharpe,
expectedreturn = expectedreturn, covmatrix = covmatrix ,
control=list(fnscale=-1),lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
optweights <- rbind(optweights, 1-sum(optweights))
#Indexed Portfolio
indexportfolio <- data.frame()
for(c in 1:ncol(data)){
indexportfolio[1,c] <- 100
}
for(c in 1:ncol(data)){
for(r in 1:nrow(returns)){
indexportfolio[r+1,c] <- indexportfolio[r,c]*(1+returns[r,c])
}
}
colnames(indexportfolio) <- NULL
rownames(indexportfolio) <- NULL
#test <- as.matrix(indexportfolio[1,])
portfolio <- data.frame()
for(r in 1:nrow(indexportfolio)){
portfolio[r,1] <- as.matrix(indexportfolio[r,]) %*% optweights
}
return(plot(portfolio))
}
opt(finaldata)
### Sharperatio optimized pure Equity Portfolio
# Takes a dataframe with all final data as input
optimpf <- function(data){
#get past returns
returns <- data.frame()
for(c in 1:ncol(data)){
for(r in 1:nrow(data)-1){
returns[r,c] <- (data[r+1,c]-data[r,c])/data[r,c]
}
}
#startingweights for optimisation
startingweights <- as.matrix(rep(1/ncol(data),length.out=(ncol(data)-1)))
expectedreturn <- as.matrix(rep(0,length.out=ncol(data)))
#return and covariances as matrixes
returnmatrix <- as.matrix(returns[,])
covmatrix <- cov(returnmatrix)
#expected returns for every stock
for(c in 1:ncol(returns)){
expectedreturn[c,1] <- mean(returns[,c])
}
#Find Optimal portfolioweights
optweights <- optim(par = as.vector(startingweights), fn = sharpe,
expectedreturn = expectedreturn, covmatrix = covmatrix ,
control=list(fnscale=-1),lower = 0, method = "L-BFGS-B")
optweights <- as.matrix(optweights$par)
optweights <- rbind(optweights, 1-sum(optweights))
#Indexed Portfolio
indexportfolio <- data.frame()
for(c in 1:ncol(data)){
indexportfolio[1,c] <- 100
}
for(c in 1:ncol(data)){
for(r in 1:nrow(returns)){
indexportfolio[r+1,c] <- indexportfolio[r,c]*(1+returns[r,c])
}
}
colnames(indexportfolio) <- NULL
rownames(indexportfolio) <- NULL
portfolio <- data.frame()
for(r in 1:nrow(indexportfolio)){
portfolio[r,1] <- as.matrix(indexportfolio[r,]) %*% optweights
}
return(portfolio)
}
